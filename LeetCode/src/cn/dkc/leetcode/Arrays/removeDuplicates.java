package cn.dkc.leetcode.Arrays;

import java.util.HashMap;
import java.util.Map;

/*给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。*/
//下面方法用map集合做  不符合题的意思  重做
public class removeDuplicates {
	//数组必须有序才可以
	public int moveduplicates(int[] arr) {
		int count = 0;
		//0,0,1,1,1,2,2,3,4,4,5}
		for(int i= 0;i<arr.length;i++) {
			for(int j = i+1;j<arr.length;j++) {
				if(arr[i]==arr[j]) {
					count++;
					break;
				}
			}
		}
		int k = 1;
		int me = 0;
		for(int i = 0;i<arr.length-1;i+=me) {
			me = 1;
			for(int j = i+1;j<arr.length;j++) {
				if(arr[i]!=arr[j]) {
					arr[k] = arr[j];
					k++;
					break;
				}
				else
					me++;
			}
		}
		return arr.length - count;
	}
	public static void main(String[] args) {
		int arr[] = {0,0,1,1,1,2,2,3,4,4,5};
		moveDuplicates(arr);
		System.out.println();
		int len = new removeDuplicates().moveduplicates(arr);
		for(int i = 0;i<len;i++) {
			System.out.print(arr[i]+" ");
		}
	}
	
	public static void moveDuplicates(int[] arr) {
		int count = 0;
		Map<Integer,Integer> mp = new HashMap<Integer,Integer>();
		for(int i = 0;i<arr.length;i++) {
			if(!mp.containsKey(arr[i])) {
				mp.put(arr[i], count);
				for(int j = i+1;j<arr.length;j++) {
					if(mp.containsKey(arr[j])) {
						mp.put(arr[j],++count);
					}
				}
			}
		}
		for(Map.Entry<Integer, Integer> s:mp.entrySet()) {
			System.out.print(s.getKey()+" ");
		}
	}
}
